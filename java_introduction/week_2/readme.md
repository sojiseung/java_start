## 형변환

int -> long -> double
- 작은 범위에서 큰 범위로는 대입할 수 있다. (이것을 묵시적 형변환 또는 자동 형변환이라 한다.)
- 큰 범위에서 작은 범위의 대입은 다음과 같은 문제가 발생
  1. 소수점 버림
  2. 오버플로우
- 연산과 형변환
   1. 같은 타입은 같은 결과를 낸다.
   2. 서로 다른 타입의 계산은 큰 범위로 자동 형변환
 
1. 형변환과 오버플로우
- 형변환을 할 때 작은 숫자가 표현할 수 있는 범위를 넘어서면 오버플로우가 발생한다.
- 보통 오버플로우가 발생하면 마치 시계가 한바퀴 돈 것 처럼 다시 처음부터 시작한다. (int를 기준으로 int에 최소값인 -2147483648부터 다시 시작하게 된다.)
- 만약 오버플로우가 발생하게 되면 그 결과값을 활용하기 보다는 대입하는 변수의 타입을 변경을 하자

2. 계산과 형변환

형변환은 대입 뿐만 아니라, 계산을 할 때도 발생한다.

- 같은 타입끼리의 계산은 같은 타입의 결과를 나타낸다 (int와 int를 계산하면 int를, double와 double를 계산하면 double를 출력함)
- 서로 다른 타입의 계산은 큰 범위로 자동 형변환(int와 long를 계산하면 long, int와 double를 계산하면 double)

        int div1 = 3 / 2;
        System.out.println("div1 = " + div1);
        // 값은 1
        
        double div2 = 3 / 2;
        System.out.println("div2 = " + div2);
        // 1 -> 1.0 1을 double로 형변환 
        
        double div3 = 3.0 / 2;
        System.out.println("div3 = " + div3);
        // 1.5 -> 1.5 3.0 double 나누기 int로 계산 double로 값이 출력
        
        double div4 = (double) 3 / 2;
        System.out.println("div4 = " + div4);
        // 3을 double로 형변환 후 계산 나머지는 위와 같음
  

## 스코프

변수는 선언한 위치에 따라 지역 변수, 멤버 변수(클래스 변수, 인스턴스 변수)와 같이 분류

지역 변수는 이름 그대로 특정 지역에서만 사용할 수 있는 변수라는 뜻이다. 그 특정 지역을 벗어나면 사용할 수 없다.
여기서 말하는 지역이 바로 변수가 선언된 코드 블럭({})이다. 코드 블럭 안에서 선언한 변수들은 코드 블럭 밖으로 나가면 제거가 된다 따라서 이후에는 접근을 할 수 없다.

이렇게 변수의 접근 가능한 범위를 우리는 스코프(scope)라고 부른다. 

스코프라는 개념을 만든 이유
- 비효율적인 메모리 사용 : 조건문이나 반복문에 잠깐 사용되고 버려지는 변수를 메인 코드 블록에 선언을 했을때 조건문이나 반복문이 종료가 되어도 변수가 존재하기 때문에 불필요한 메모리가 낭비된다. 만약 조건문이나 반복문 코드 블록 안에 변수를 선언한다면 종료가 되는 시점에서 임시로 사용되는 이 변수들은 제거가 된다. 따라서 불필요한 변수를 메모리에서 제거했기 때문에 조금 더 효율적으로 메모리를 사용할 수 있다.
- 코드 복잡성 증가 : 좋은 코드는 군더더기 없는 단순한 코드이다. if문에서 잠깐 쓰고 버려질 변수를 메인 메서드에 선언을 하면 코딩이 끝날때까지 우리는 그 변수를 게속 염두하고 코드 작성을 해야된다 변수가 많아지면 그 만큼 생각을 해야되는 변수도 많아지기 때문에 상황에 따라 알맞게 변수를 선언하는것이 중요하다.


## Scanner

Scanner scanner(이름은 바꿀 수 있음) = new Scanner(System.in);

예시)

        System.out.print("문자열을 입력하세요 : ");
        String str = scanner.nextLine(); // 입력을 String으로 가져온다.
        System.out.println("입력한 문자열 : " + str);

        System.out.print("정수를 입력하세요 : ");
        int intValue = scanner.nextInt();   // 입력을 int로 가져온다.
        System.out.println("입력한 정수 : " + intValue);

        System.out.print("정수를 입력하세요 : ");
        double doubleValue = scanner.nextDouble();  // 입력을 double로 가져온다.
        System.out.println("입력한 실수 :  " + doubleValue);

* 참고로 nextLine();를 제외한 나머지는 scanner로 입력을 받고 enter를 누르면 \n(개행문자)를 무시하고 넘긴다. 이때 버퍼에는 \n(개행문자)가 남아 있는데 다음에 nextLine();을 사용하면 버퍼에 남아있던 \n(개행문자)를 enter로 인식하고 사용자가 입력한 값을 안받고 넘어가버린다. 그래서 (next, nextInt)를 사용하고 다음에 바로 nextLine();을 사용해서 버퍼에 남아있는 개행문자를 처리해줘야한다.

## 배열

배열은 같은 타입의 변수를 사용하기 편하게 하나로 묶어둔 것이다.

1. 배열 변수 선언
   - 배열을 사용하려면 int[] students;와 같이 배열 변수를 선언해야 한다.
   - 일반적인 변수와 차이점은 int[]처름 타입 다음에 대괄호([])가 들어간다는 점이다.
   - 배열 변수를 선언한다고해서 아직 사용할 수 있는 배열이 만들어진 것은 아니다!
     - int a에는 정수를, double b에는 실수를 담을 수 있다.
     - int[] students와 같은 배열변수에는 배열을 담을 수 있다.(배열 변수에는 10, 20같은 값이 아니라 배열이라는 것을 담을 수 있다.)

2. 배열 생성
   - 배열을 사용하려면 배열을 생성해야 한다.
   - new int[5]라고 입력하면 오른쪽 그림과 같이 총 5개의 int형 변수가 만들어진다.
   - new는 새로 생성한다는 뜻이고, int[5]는 int형 변수 5개하는 뜻이다. 따라서 int형 변수 5개를 다룰 수 있는 배열을 새로 만든다는 뜻이다.
   - 앞서 int student1, int student2 ... intstudent5까지 총 5개의 변수를 직접 선언했다. 배열을 사용하면 이런 과정을 한번에 깔끔하게 처리할 수 있다.

3. 배열과 초기화
   - new int[5]라고 하면 총 5개의 int형 변수가 만들어진다. 자바는 배열을 생성할 때 내부값을 자동으로 초기화한다.
   - 숫자는 -, boolean은 false, String은 null(없다는 뜻이다.)로 초기화 된다.

4. 배열 초기값 보관
   - new int[5]로 배열을 생성하면 배열의 크기만큼 메모리를 확보한다.
     -int형을 5개 사용하면 4byte * 5 -> 20byte를 확보한다.
   - 배열을 생성하고 나면 자바는 메모리 어딘가에 있는 이 배열에 접근할 수 있는 참조값(주소)(x001)을 반환한다.
     - 여기서 x001이라고 표현한 것이 참조값이다. (실제로 x001처럼 표현되는 것은 아니고 이해를 돕기 위한 예시이다.)
   - 앞서 선언한 배열 변수인 int[] students에 생성된 배열의 참조값(x001)을 보관한다.
   - int[] students 변수는 new int[5]로 생성한 배열의 참조값을 가지고 있다.
     - 이 변수는 참조값을 가지고 있다. 이 참조값을 통해 배열을 참조할 수 있다. 쉽게 이야기해서 참조값을 통해 메모리에 있는 실제 배열에 접근하고 사용할 수 있다.
     - 참고로 배열을 생성하는 new int[5] 자체에는 아무런 이름이 없다! 그냥 int형 변수를 5개 연속으로 만드는 것이다. 따라서  생성한 배열에 접근하는 방법이 필요하다. 따라서 배열을 생성할 때 반환되는 참조값을 어딘가에 보간해두어야 한다. 앞서 int[] students변수에 참조값(x001)을 보관했었다. 이 변수를 통해서 이 배열에 접근할 수 있다.
       int[] students = new int[5]; //1. 배열 생성
       int[] students = x001; //2. new int[5]의 결과로 x001 참조값 반환
       students = x001 //3. 최종 결과

5. 배열 사용
   - 인덱스
     - 배열은 변수와 사용법이 비슷한데, 차이점이 있다면 다음과 같이 []사이에 숫자 번호를 넣어주면 된다. 배열의 위치를 나타내는 숫자를 인덱스(index)라 한다.
     - 배열은 0부터 시작한다 new int[5]와 같이 5개의 요소를 가지는 int형 배열을 만들었다면 인덱스는 0, 1, 2, 3, 4가 존재한다. 여기서 주의해야 할 점이 있는데 인덱스는 0부터 시작한다는 것이다. 배열의 요소를 5개로 생성했지만, 인덱스는 0부터 시작한다. 따라서 사용 간으한 인덱스의 범위는 0 ~ (n-1)이 된다. 그래서 students[4]가 배열의 마지막 요소이다.

6. 기본형 vs 참조형
   - 자바의 변수 데이터 타입을 가장 크게 보면 기본형과 참조형으로 분류할 수 있다. 사용하는 값을 직접 널을 수 있는 기본형, 그리고 방금 본 배열 변수와 같이 메모리의 참조값을 넣을 수 있는 참조형으로 분류할 수 있다.
     - 기본형 : 우리가 지금까지 봤던 in, long, double, boolean처럼 변수에 사용할 값을 직접 넣을 수 있는 데이터 타입을 기본형이라 한다.
     - 참조형 : int[] students와 같이 데이터에 접근하기 위한 참조(주소)를 저장하는 데이터타입을 참조형이라 한다. 뒤에서 학습하는 객체나 클래스를 담을 수 있는 변수들도 모두 참조형이다.

배열을 복잡하게 참조형을 사용하는 이유는 배열은 동적으로 사이즈를 변경할 수 있기 때문이다.

예시 ) 
      int size=10000; //사용자가 입력한 값을 넣었다고 가정해보자.
      new int[size]; //이 코드가 실행되는 시점에 배열의 크기가 정해진다.

- 기본형은 선언과 동시에 크기가 정해진다. 따라서 크기를 동적으로 바꾸거나 할 수는 없다. 반면에 앞서본 배열과 같은 참조형은 크기를 동적으로 할당할 수 있다. 예를 들어서 Scanner를 사용해서 사용자 입력에 따라 size변수의 값이 변하고, 생성되는 배열의 크기도 달라질 수 있다. 이런 것을 동적 메모리 할당이라 한다. 기본형은 선언과 동시에 사이즈가 정적으로 정해지지만, 참조형을 사용하면 이처럼 동적으로 크기가 변해서 유연성을 제공할 수 있다.
- 기본형은 사용할 값을 직접 저장한다. 반면에 참조형은 메모리에 저장된 배열이나 객체의 참조를 저장한다. 이로인해 참조형은 더 복잡한 데이터 구조를 만들고 관리할 수 있다. 반면 기본형응 더 빠르고 메모리를 효율적으로 처리한다.


## 메서드

- 자바에서는 함수를 메서드(Method)라 한다 메서드도 함수의 한 종류라고 생각하면 된다.

public static int add(int a, int b) {
        System.out.println(a + " + " + b + " 연산 수행을 합니다.");
        int sum = a + b;
        return sum;
    }


